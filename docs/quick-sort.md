# 排序算法——快速排序

选择一个基准元素，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

## 基本快速排序

[4, 6, 2, 3, 1, 5, 7, 8]
以4为基准元素，
[1, 6, 2, 3, 4, 5, 7, 8]

[1, 4, 2, 3, 6, 5, 7, 8]



[21, 32, 43, 98, 54, 45, 23, 4,	66, 86]

21为基数，i指向21（index: 0），j指向86（index: 9）
第1趟
从后往前，找到第一个比21小的元素4，21和4替换：
[4, 32, 43, 98, 54, 45, 23, 21,	66, 86]
此时i为4（index: 0），j为23（index: 6）

再从前往后，找到第一个比21大的元素32，32和21替换：
[4, 21, 43, 98, 54, 45, 23, 32,	66, 86]
i为43（index: 2），j为23（index: 6）

i为43，j为4

4已经在43前面了，第1趟结束


4	21	43	98	54	45	23	32	66	86



## 双路快速排序

[52, 34, 61, 89, 95, 89, 9, 28, 46, 50]

以第一个元素52为基准，设定i和j两个指针，初始时i指向34，j指向50。
第1趟：
比较52和34，34比52小，维持不动，i指针挪到61；// [52, 34, 61, 89, 95, 89, 9, 28, 46, 50]
比较52和61，61比52大，再比较52和50，50比52小，50和61交换，且i挪到89，j挪到46；// [52, 34, 50, 89, 95, 89, 9, 28, 46, 61]
比较52和89，89比52大，再比较52和46，46比52小，89和46交换，且i挪到95，j挪到28；// [52, 34, 50, 46, 95, 89, 9, 28, 89, 61]
比较52和95，95比52大，再比较52和28，28比52小，95和28交换，且i挪到89，j挪到9；// [52, 34, 50, 46, 28, 89, 9, 95, 89, 61]
比较52和89，89比52大，再比较52和9，9比52小，89和9交换；// [52, 34, 50, 46, 28, 9, 89, 95, 89, 61]
经过第1趟比较，数组被分成了两组，第1组[34, 50, 46, 28, 9]的元素都比第2组[89, 95, 89, 61]的小。
第1趟排序的结果是：
[34, 50, 46, 28, 9, 52, 89, 95, 89, 61]

分别对这两组元素使用快速排序。

以第一个元素34为基准，设定i和j两个指针，初始时i指向50，j指向9。
第2趟（对第1组[34, 50, 46, 28, 9]）：
比较34和50，50比34大，再比较34和9，9比34小，50和9交换，且i挪到46，j挪到28；// [34, 9, 46, 28, 50]
比较34和46，46比34大，再比较34和28，28比34小，46和28交换；// [34, 9, 28, 46, 50]
第2趟比较的结果是：
[9, 28, 34, 46, 50]

以第一个元素89为基准，设定i和j两个指针，初始时i指向95，j指向61。
第3趟（对第2组[89, 95, 89, 61]）：
比较89和95，95比89大，再比较89和61，61比89小，95和61交换，且i和j都挪到89；// [89, 61, 89, 95]
比较89和89，两者相等；
第3趟比较的结果是：
[61, 89, 89, 95]

将第2趟和第3趟的结果合起来，就得到最终的排序结果：
[9, 28, 34, 46, 50, 52, 61, 89, 89, 95]

基准元素base和i比较：
1. 如果i比base小，则不交换，只是将i往右挪一位
2. 如果i比base大，则再将base和j比较：
  1. 如果j比base小，则i和j比较，且i往右挪一位，j往左挪一位
  2. 如果j比base大，则不交换，只是将j往左挪一位，并将新的j和base比较：
    1. 如果新的j比base小，则将i和j交换，且i往右挪一位，j往左挪一位
    2. 如果新的j比base大，则不交换，只是将j往左挪一位，并将新的j和base比较，以此循环。

[52, 34, 61, 89, 95, 14, 1, 32, 49, 84, 49, 72, 91, 35, 29, 89, 9, 28, 46, 50]
-> 61和50交换
[52, 34, 50, 89, 95, 14, 1, 32, 49, 84, 49, 72, 91, 35, 29, 89, 9, 28, 46, 61]
-> 89和46交换
[52, 34, 50, 46, 95, 14, 1, 32, 49, 84, 49, 72, 91, 35, 29, 89, 9, 28, 89, 61]
-> 95和28交换
[52, 34, 50, 46, 28, 14, 1, 32, 49, 84, 49, 72, 91, 35, 29, 89, 9, 95, 89, 61]
-> 84和9交换
[52, 34, 50, 46, 28, 14, 1, 32, 49, 9, 49, 72, 91, 35, 29, 89, 84, 95, 89, 61]
-> 72和29交换
[52, 34, 50, 46, 28, 14, 1, 32, 49, 9, 49, 29, 91, 35, 72, 89, 84, 95, 89, 61]
-> 91和35交换
[52, 34, 50, 46, 28, 14, 1, 32, 49, 9, 49, 29, 35, 91, 72, 89, 84, 95, 89, 61]

第1趟结果：
[34, 50, 46, 28, 14, 1, 32, 49, 9, 49, 29, 35, 52, 91, 72, 89, 84, 95, 89, 61]

第2趟
[34, 50, 46, 28, 14, 1, 32, 49, 9, 49, 29, 35]
以34为基准，初始时i指向50，i指向35
比较34和50，50比34大，再比较34和35，35比34大，j挪到29，比较34和29，29比34小，29和50交换，且i挪到46，j挪到49；// [34, 29, 46, 28, 14, 1, 32, 49, 9, 49, 50, 35]
比较34和46，46比34大，再比较34和49，49比34大，j挪到9，比较34和9，9比34小，46和9交换，且i挪到28，j挪到49（另一个49）；// [34, 29, 9, 28, 14, 1, 32, 49, 46, 49, 50, 35]
比较34和28，28比34小，i挪到14，i挪到1，i挪到32，i挪到49（i和j重叠）；

第2趟结果：
[29, 9, 28, 14, 1, 32, 34, 49, 46, 49, 50, 35]

[29, 9, 28, 14, 1, 32]
34
[49, 46, 49, 50, 35]]

第3趟
[91, 72, 89, 84, 95, 89, 61]
